{"path":"keys/exam.pdf","text":"exam Exam 2009_code_lastK #include <iostream> struct Node { int data; Node* link; }; void create(Node* p, int a[], int pos, int length) { if (pos < length) { p\u0000\u0000data = a[pos]; p\u0000\u0000link = new Node; p\u0000\u0000link\u0000\u0000data = 0; \u0000\u0000 用0作为结束标志 create(p\u0000\u0000link, a, pos + 1, length); } } int getLastK(Node* p, int k) { Node* p_fast = p, * p_slow = p; while (\u0000\u0000k \u0000\u0000 p_fast\u0000\u0000link \u0000\u0000 NULL) p_fast = p_fast\u0000\u0000link; p_fast = p_fast\u0000\u0000link; while (p_fast\u0000\u0000data) { p_slow = p_slow\u0000\u0000link; p_fast = p_fast\u0000\u0000link; } return p_slow\u0000\u0000data; 太复杂了，不要那么模块化，因为我是考试写的，因此，只需要必要的数据结构定义， 然后一个 main 汉书就可以了，确保语法 c++ 标准，结构用结构体，不要清理内存，假 设是已经有了数据结构 2010_code_circle_leftmove } int main() { Node p; int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; create(&p, a, 0, 10); int ret = getLastK(&p, 7); cout \u0000\u0000 \"倒数第7个元素是：\" \u0000\u0000 ret \u0000\u0000 endl; return 0; } #include <iostream> #include <vector> void reverse(std\u0000\u0000vector<int>& a, int start, int end) { while (start < end) { std\u0000\u0000swap(a[start], a[end]); \u0000\u0000start; \u0000\u0000end; } } 2011_code_double_divide void move(std\u0000\u0000vector<int>& a, int p) { reverse(a, 0, p - 1); reverse(a, p, a.size() - 1); reverse(a, 0, a.size() - 1); } int main() { std\u0000\u0000vector<int> a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; move(a, 7); for (int num : a) { std\u0000\u0000cout \u0000\u0000 num \u0000\u0000 \" \"; } std\u0000\u0000cout \u0000\u0000 std\u0000\u0000endl; return 0; } #include <iostream> #include <vector> int getMiddle(const std\u0000\u0000vector<int>& a, int start, int end) { return a[(start + end) / 2]; } int getDoubleMid(const std\u0000\u0000vector<int>& s1, const std\u0000\u0000vector<int>& s2) { int length = s1.size(); int i = 0, log_i = 1; while (log_i * 2 < length) { i\u0000\u0000; log_i *= 2; } int start_a = 0, start_b = 0, end_a = length - 1, end_b = length - 1; while (i\u0000\u0000 \u0000\u0000 start_a < end_a \u0000\u0000 start_b < end_b) { int mid_a = getMiddle(s1, start_a, end_a); int mid_b = getMiddle(s2, start_b, end_b); if (mid_a < mid_b) { start_a = (start_a + end_a) / 2 + 1; end_b = (start_b + end_b) / 2 - 1; } else { start_b = (start_b + end_b) / 2 + 1; end_a = (start_a + end_a) / 2 - 1; } 2012_code_doublelink } return std\u0000\u0000min(s1[start_a], s2[start_b]); } int main() { std\u0000\u0000vector<int> s1 = {1, 2, 3, 8, 9}; std\u0000\u0000vector<int> s2 = {4, 5, 6, 7, 10}; int ret = getDoubleMid(s1, s2); std\u0000\u0000cout \u0000\u0000 \"Result: \" \u0000\u0000 ret \u0000\u0000 std\u0000\u0000endl; return 0; } #include <iostream> struct Node { char data; Node* link; }; void create(Node* p, const std\u0000\u0000string& a, int pos) { if (pos < a.length()) { p\u0000\u0000data = a[pos]; p\u0000\u0000link = new Node; p\u0000\u0000link\u0000\u0000data = '\\0'; create(p\u0000\u0000link, a, pos + 1); } } Node* getSameNode(Node* a, Node* b) { int a_length = 0, b_length = 0; Node* a_p = a\u0000\u0000link, * b_p = b\u0000\u0000link; while (a_p\u0000\u0000data \u0000\u0000 '\\0') { a_length\u0000\u0000; a_p = a_p\u0000\u0000link; } while (b_p\u0000\u0000data \u0000\u0000 '\\0') { b_length\u0000\u0000; b_p = b_p\u0000\u0000link; } Node* a_scan = a\u0000\u0000link, * b_scan = b\u0000\u0000link; while (a_length < b_length) { b_scan = b_scan\u0000\u0000link; b_length\u0000\u0000; } while (b_length < a_length) { a_scan = a_scan\u0000\u0000link; a_length\u0000\u0000; } while (a_length\u0000\u0000 > 0) { if (a_scan \u0000\u0000 b_scan) return a_scan; a_scan = a_scan\u0000\u0000link; 2013_code_mian_ele b_scan = b_scan\u0000\u0000link; } return nullptr; } int main() { Node a, b; create(&a, \"loading\", 0); create(&b, \"being\", 0); Node* tmp = b.link\u0000\u0000link\u0000\u0000link; b.link\u0000\u0000link = a.link\u0000\u0000link\u0000\u0000link\u0000\u0000link; delete tmp; Node a_with_head, b_with_head; a_with_head.link = &a; b_with_head.link = &b; Node* same = getSameNode(&a_with_head, &b_with_head); if (same) { std\u0000\u0000cout \u0000\u0000 \"Same node found: \" \u0000\u0000 same\u0000\u0000data \u0000\u0000 std\u0000\u0000endl; } else { std\u0000\u0000cout \u0000\u0000 \"No same node found\" \u0000\u0000 std\u0000\u0000endl; } return 0; } #include <iostream> #include <vector> bool majority(const std\u0000\u0000vector<int>& A) { int start = 0, count = 0; for (int j = 0; j < A.size(); j\u0000\u0000) { if (A[start] \u0000\u0000 A[j]) count\u0000\u0000; else count\u0000\u0000; if (count \u0000\u0000 0 \u0000\u0000 j < A.size() - 1) { start = \u0000\u0000j; count = 1; } } int mainElement = A[start]; 2014_code_getwpl int countElement = 0; for (int num : A) { if (num \u0000\u0000 mainElement) countElement\u0000\u0000; } return countElement > A.size() / 2; } int main() { std\u0000\u0000vector<int> A = {1, 1, 0, 0, 0, 1, 1, 1, 0}; bool isMajority = majority(A); if (isMajority) { std\u0000\u0000cout \u0000\u0000 \"有主元素\" \u0000\u0000 std\u0000\u0000endl; } else { std\u0000\u0000cout \u0000\u0000 \"没有主元素\" \u0000\u0000 std\u0000\u0000endl; } return 0; } #include <iostream> #include <vector> struct TreeNode { int weight; TreeNode* left; TreeNode* right; TreeNode(int w) : weight(w), left(nullptr), right(nullptr) {} }; void create(TreeNode* node, const std\u0000\u0000vector<int>& c, int pos) { if (pos < c.size()) { node\u0000\u0000weight = c[pos]; if (pos * 2 + 1 < c.size()) { node\u0000\u0000left = new TreeNode(0); create(node\u0000\u0000left, c, pos * 2 + 1); } if (pos * 2 + 2 < c.size()) { node\u0000\u0000right = new TreeNode(0); create(node\u0000\u0000right, c, pos * 2 + 2); } } } int getWPL(TreeNode* root, int depth) { if (root \u0000\u0000 nullptr) return 0; if (root\u0000\u0000left \u0000\u0000 nullptr \u0000\u0000 root\u0000\u0000right \u0000\u0000 nullptr) { return depth * root\u0000\u0000weight; } return getWPL(root\u0000\u0000left, depth + 1) + getWPL(root\u0000\u0000right, depth + 1); } int main() { std\u0000\u0000vector<int> c = {54, 4654, 7565, 234, 436546, 876876, 353, 757, 2, 345, 23, 445, 1, 235, 0, 6346}; TreeNode* root = new TreeNode(0); create(root, c, 0); int wpl = getWPL(root, 0); std\u0000\u0000cout \u0000\u0000 \"WPL: \" \u0000\u0000 wpl \u0000\u0000 std\u0000\u0000endl; return 0; }","libVersion":"0.3.2","langs":""}